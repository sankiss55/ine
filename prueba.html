<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <title>Visualizador de Activaci√≥n IA Correcto</title>
    <script src="https://cdn.jsdelivr.net/npm/onnxruntime-web/dist/ort.min.js"></script>
    <style>
        body { font-family: 'Segoe UI', sans-serif; background: #0f172a; color: white; display: flex; flex-direction: column; align-items: center; padding: 20px; }
        .card { background: #1e293b; padding: 2rem; border-radius: 15px; text-align: center; max-width: 700px; }
        
        /* CONTENEDOR DE IM√ÅGENES APILADAS */
        .image-stack {
            position: relative;
            width: 640px;  /* Ancho fijo para alinear */
            height: 640px; /* Alto fijo para alinear */
            margin: 20px auto;
            border: 2px solid #334155;
            border-radius: 8px;
            overflow: hidden;
            background: #000;
        }
        
        /* Las im√°genes se enciman una sobre otra */
        .stack-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }
        
        /* El canvas de la IA debe estar arriba y permitir clicks a trav√©s de √©l si fuera necesario */
        #overlay-canvas {
            pointer-events: none; 
            /* mix-blend-mode: screen; Ideal para mapas de calor oscuros */
        }

        .hidden { display: none; }
        #status { color: #4ade80; margin-top: 10px; font-weight: bold; }
        .btn { background: #38bdf8; color: #0f172a; padding: 10px 20px; border-radius: 5px; cursor: pointer; font-weight: bold; display: inline-block; margin-bottom: 20px;}
    </style>
</head>
<body>

<div class="card">
    <h1>IA: Mapa de Captura Visual (Heatmap)</h1>
    
    <label class="btn">
        Seleccionar Imagen
        <input type="file" id="fileInput" accept="image/*" style="display:none">
    </label>
    <p id="status">Cargando modelo...</p>

    <div class="image-stack">
        <img id="preview-image" class="stack-layer" alt="Vista previa">
        <canvas id="overlay-canvas" class="stack-layer"></canvas>
    </div>
</div>

<canvas id="process-canvas" class="hidden"></canvas>

<script>
    // *** AJUSTA ESTO SI TU MODELO USA OTRAS DIMENSIONES ***
    const WIDTH = 640;
    const HEIGHT = 640;
    
    const MODEL_PATH = './modelo.onnx'; 
    let session;

    async function init() {
        try {
            session = await ort.InferenceSession.create(MODEL_PATH, { executionProviders: ['wasm'] });
            document.getElementById('status').innerText = "‚úÖ IA Lista. Sube una imagen.";
        } catch (e) {
            alert("Error al cargar modelo: " + e.message);
            document.getElementById('status').innerText = "‚ùå Error de modelo.";
        }
    }

    document.getElementById('fileInput').onchange = function(e) {
        const file = e.target.files[0];
        if (!file) return;
        
        // Limpiar canvas anterior
        const canvas = document.getElementById('overlay-canvas');
        const ctx = canvas.getContext('2d');
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        const reader = new FileReader();
        reader.onload = function(event) {
            const img = document.getElementById('preview-image');
            img.src = event.target.result;
            // Aseguramos que las capas tengan el tama√±o correcto
            img.onload = () => {
                 document.getElementById('overlay-canvas').width = WIDTH;
                 document.getElementById('overlay-canvas').height = HEIGHT;
                 procesarImagen(img);
            };
        };
        reader.readAsDataURL(file);
    };

    async function procesarImagen(imgElement) {
        const status = document.getElementById('status');
        if (!session) { alert("Modelo no cargado"); return; }
        status.innerText = "üß† Procesando...";

        // 1. Preprocesamiento en canvas oculto
        const procCanvas = document.getElementById('process-canvas');
        procCanvas.width = WIDTH;
        procCanvas.height = HEIGHT;
        const ctx = procCanvas.getContext('2d');
        ctx.drawImage(imgElement, 0, 0, WIDTH, HEIGHT);

        const imageData = ctx.getImageData(0, 0, WIDTH, HEIGHT).data;
        const inputData = new Float32Array(WIDTH * HEIGHT * 3);
        
        // Normalizaci√≥n est√°ndar (0-1)
        for (let i = 0, j = 0; i < imageData.length; i += 4) {
            inputData[j] = imageData[i] / 255.0;           // R
            inputData[j + WIDTH * HEIGHT] = imageData[i+1] / 255.0; // G
            inputData[j + 2 * WIDTH * HEIGHT] = imageData[i+2] / 255.0; // B
            j++;
        }

        try {
            const tensor = new ort.Tensor('float32', inputData, [1, 3, HEIGHT, WIDTH]);
            // RECUERDA: Usa 'images' o 'input' seg√∫n tu modelo
            const results = await session.run({ images: tensor });
            
            const outputKey = Object.keys(results)[0];
            const outputData = results[outputKey].data;

            console.log(`Salida tiene ${outputData.length} valores. Dibujando...`);
            
            // 2. DIBUJAR EL RESULTADO CORREGIDO
            dibujarMapaIA(outputData);
            status.innerText = "‚úÖ Captura visualizada (Mapa de calor).";

        } catch (err) {
            alert("Error Inferencia: " + err.message);
            status.innerText = "‚ùå Error.";
        }
    }

    // --- FUNCI√ìN CORREGIDA PARA DIBUJAR ---
    function dibujarMapaIA(data) {
        const canvas = document.getElementById('overlay-canvas');
        const ctx = canvas.getContext('2d');
        // Limpiamos por si acaso
        ctx.clearRect(0,0, WIDTH, HEIGHT);

        const imgOut = ctx.createImageData(WIDTH, HEIGHT);
        const rgbaData = imgOut.data;

        // Paso A: Encontrar el rango de valores (Min/Max) para normalizar
        let maxVal = -Infinity;
        let minVal = Infinity;
        for (let i = 0; i < data.length; i++) {
            if (data[i] > maxVal) maxVal = data[i];
            if (data[i] < minVal) minVal = data[i];
        }
        const range = maxVal - minVal + 0.00001; // Evitar divisi√≥n por cero

        // Paso B: Convertir cada valor de la IA en un color RGBA
        // Asumimos que 'data' es un array plano que corresponde a HxW
        for (let i = 0; i < data.length; i++) {
            // Normalizamos el valor entre 0.0 y 1.0
            const normalized = (data[i] - minVal) / range;
            
            // √çndice en el array de p√≠xeles RGBA (4 posiciones por p√≠xel)
            const pixelIndex = i * 4;

            // --- L√ìGICA DE MAPA DE CALOR ROJO ---
            
            // Rojo: Siempre al m√°ximo (255) para que se vea "caliente"
            rgbaData[pixelIndex + 0] = 255; 
            
            // Verde y Azul: Disminuyen cuanto mayor es la activaci√≥n.
            // (Si normalized es 1, G y B son 0 -> Rojo puro)
            // (Si normalized es 0, G y B son 255 -> Blanco/Gris)
            rgbaData[pixelIndex + 1] = Math.floor(255 * (1 - normalized)); 
            rgbaData[pixelIndex + 2] = Math.floor(255 * (1 - normalized));

            // Alpha (Opacidad): Aqu√≠ est√° la clave.
            // Solo mostramos las activaciones fuertes. 
            // Si es menor a 0.3 (30%), lo hacemos totalmente transparente.
            let opacity = 0;
            if (normalized > 0.3) {
                opacity = Math.floor(normalized * 200); // Max opacidad de 200 sobre 255
            }
            rgbaData[pixelIndex + 3] = opacity;
        }

        // Ponemos la nueva imagen transparente sobre el canvas superior
        ctx.putImageData(imgOut, 0, 0);
    }

    init();
</script>
</body>
</html>
    const WIDTH = 640;
    const HEIGHT = 640;
    let session;

    async function init() {
        try {
            session = await ort.InferenceSession.create(MODEL_PATH, { executionProviders: ['wasm'] });
            document.getElementById('status').innerText = "‚úÖ IA Lista. Sube una imagen.";
        } catch (e) {
            alert("Error al cargar modelo: " + e.message);
        }
    }

    document.getElementById('fileInput').onchange = function(e) {
        const file = e.target.files[0];
        if (!file) return;
        const reader = new FileReader();
        reader.onload = function(event) {
            const img = document.getElementById('preview');
            img.src = event.target.result;
            img.style.display = 'block';
            img.onload = () => procesarEInyectar(img);
        };
        reader.readAsDataURL(file);
    };

    async function procesarEInyectar(imgElement) {
        const status = document.getElementById('status');
        status.innerText = "üß† Pensando...";

        const procCanvas = document.getElementById('process-canvas');
        const ctx = procCanvas.getContext('2d');
        procCanvas.width = WIDTH;
        procCanvas.height = HEIGHT;
        ctx.drawImage(imgElement, 0, 0, WIDTH, HEIGHT);

        const imageData = ctx.getImageData(0, 0, WIDTH, HEIGHT).data;
        const input = new Float32Array(WIDTH * HEIGHT * 3);
        for (let i = 0, j = 0; i < imageData.length; i += 4) {
            input[j] = imageData[i] / 255.0;
            input[j + WIDTH * HEIGHT] = imageData[i+1] / 255.0;
            input[j + 2 * WIDTH * HEIGHT] = imageData[i+2] / 255.0;
            j++;
        }

        try {
            const tensor = new ort.Tensor('float32', input, [1, 3, HEIGHT, WIDTH]);
            const results = await session.run({ images: tensor });
            const outputKey = Object.keys(results)[0];
            const outputData = results[outputKey].data;

            // DIBUJAR LO QUE LA IA VE
            dibujarMapaIA(outputData);
            status.innerText = "‚úÖ Captura visualizada sobre la imagen.";
        } catch (err) {
            alert("Error: " + err.message);
        }
    }

    function dibujarMapaIA(data) {
        const canvas = document.getElementById('overlay-canvas');
        const ctx = canvas.getContext('2d');
        canvas.width = WIDTH;
        canvas.height = HEIGHT;

        // Creamos una nueva imagen basada en los n√∫meros de la IA
        const imgOut = ctx.createImageData(WIDTH, HEIGHT);
        
        // El total de valores es 310,800. Esto suele ser una matriz de probabilidad.
        // Vamos a mapear esos n√∫meros a colores (Calor: Rojo para valores altos)
        for (let i = 0; i < WIDTH * HEIGHT; i++) {
            const valor = data[i]; // El valor de activaci√≥n de la IA
            
            // Si el valor es alto, pintamos en Rojo ne√≥n para ver d√≥nde "capt√≥"
            imgOut.data[i * 4 + 0] = valor > 0.5 ? 255 : 0; // Rojo
            imgOut.data[i * 4 + 1] = valor * 255;           // Verde (variaci√≥n)
            imgOut.data[i * 4 + 2] = 0;                     // Azul
            imgOut.data[i * 4 + 3] = valor > 0.1 ? 180 : 0; // Opacidad basada en intensidad
        }

        ctx.putImageData(imgOut, 0, 0);
    }

    init();
</script>
</body>
</html>
