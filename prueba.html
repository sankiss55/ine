<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <title>YOLOv8 Ultra-Fast Segment</title>
    <script src="https://cdn.jsdelivr.net/npm/onnxruntime-web/dist/ort.min.js"></script>
    <style>
        body { font-family: sans-serif; background: #070b14; color: white; display: flex; flex-direction: column; align-items: center; margin: 0; padding: 10px; }
        .container { position: relative; width: 640px; height: 480px; border-radius: 12px; overflow: hidden; border: 3px solid #0ea5e9; }
        #video, #overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; }
        #overlay { pointer-events: none; }
        .status { background: rgba(14, 165, 233, 0.2); padding: 10px 20px; border-radius: 20px; margin-bottom: 10px; font-size: 14px; border: 1px solid #0ea5e9; }
    </style>
</head>
<body>

    <div class="status" id="status">Cargando IA...</div>

    <div class="container">
        <video id="video" autoplay playsinline muted></video>
        <canvas id="overlay"></canvas>
    </div>

<script>
    const video = document.getElementById('video');
    const canvas = document.getElementById('overlay');
    const ctx = canvas.getContext('2d', { alpha: true });
    const status = document.getElementById('status');
    
    // Configuración de optimización
    const WIDTH = 640;
    const HEIGHT = 640;
    const CONFIDENCIA_SEG = 0.9; // <--- 90% de validación
    let session;
    let frameCount = 0;

    // Canvas oculto reutilizable para no saturar la memoria
    const offscreenCanvas = document.createElement('canvas');
    offscreenCanvas.width = WIDTH;
    offscreenCanvas.height = HEIGHT;
    const offCtx = offscreenCanvas.getContext('2d', { willReadFrequently: true });

    async function init() {
        try {
            // Usamos 'wasm' pero con hilos optimizados si están disponibles
            session = await ort.InferenceSession.create('./best.onnx', { 
                executionProviders: ['wasm'],
                graphOptimizationLevel: 'all'
            });
            
            const stream = await navigator.mediaDevices.getUserMedia({ 
                video: { facingMode: "environment", width: 640, height: 480 } 
            });
            video.srcObject = stream;
            video.onloadedmetadata = () => {
                status.innerText = "⚡ Validando al 90% - Tiempo Real";
                predict();
            };
        } catch (e) {
            status.innerText = "❌ Error: " + e.message;
        }
    }

    async function predict() {
        // OPTIMIZACIÓN: Solo procesar 1 de cada 2 frames para ganar velocidad (30fps -> 15fps de inferencia)
        // El video se sigue viendo a 60fps, pero la IA descansa un poco.
        if (frameCount % 2 === 0) {
            offCtx.drawImage(video, 0, 0, WIDTH, HEIGHT);
            const imgData = offCtx.getImageData(0, 0, WIDTH, HEIGHT).data;
            
            // Pre-proceso ultra rápido
            const input = new Float32Array(WIDTH * HEIGHT * 3);
            const area = WIDTH * HEIGHT;
            for (let i = 0; i < area; i++) {
                input[i] = imgData[i * 4] / 255.0;           // R
                input[i + area] = imgData[i * 4 + 1] / 255.0; // G
                input[i + 2 * area] = imgData[i * 4 + 2] / 255.0; // B
            }

            const tensor = new ort.Tensor('float32', input, [1, 3, HEIGHT, WIDTH]);
            
            try {
                const results = await session.run({ images: tensor });
                const outputNames = Object.keys(results);
                // Buscamos el tensor de prototipos/máscaras
                const maskData = results[outputNames[1]].data; 
                renderFast(maskData);
            } catch (e) {}
        }
        
        frameCount++;
        requestAnimationFrame(predict);
    }

    function renderFast(maskData) {
        canvas.width = video.videoWidth;
        canvas.height = video.videoHeight;
        
        // Usamos un canvas pequeño para la máscara y dejamos que el navegador la escale (muy rápido)
        const maskSize = 160;
        const tempCanvas = document.createElement('canvas');
        tempCanvas.width = maskSize;
        tempCanvas.height = maskSize;
        const tCtx = tempCanvas.getContext('2d');
        const imgOut = tCtx.createImageData(maskSize, maskSize);

        for (let i = 0; i < maskSize * maskSize; i++) {
            let val = 0;
            // Suma de prototipos
            for(let j = 0; j < 32; j++) val += maskData[i + (j * maskSize * maskSize)];
            val = val / 32;

            const p = i * 4;
            // APLICANDO VALIDACIÓN DEL 90%
            if (val > CONFIDENCIA_SEG) { 
                imgOut.data[p + 0] = 0;   // R
                imgOut.data[p + 1] = 255; // G (Verde brillante para éxito)
                imgOut.data[p + 2] = 127; // B
                imgOut.data[p + 3] = 200; // Opacidad alta
            }
        }
        
        tCtx.putImageData(imgOut, 0, 0);
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.imageSmoothingEnabled = true;
        ctx.drawImage(tempCanvas, 0, 0, canvas.width, canvas.height);
    }

    init();
</script>
</body>
</html>
