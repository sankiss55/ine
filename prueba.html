<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <title>YOLOv8 Real-Time INE Detector</title>
    <script src="https://cdn.jsdelivr.net/npm/onnxruntime-web/dist/ort.min.js"></script>
    <style>
        body { font-family: sans-serif; background: #070b14; color: white; display: flex; flex-direction: column; align-items: center; margin: 0; padding: 10px; }
        .container { position: relative; width: 640px; height: 480px; border-radius: 12px; overflow: hidden; border: 3px solid #0ea5e9; box-shadow: 0 0 20px rgba(14, 165, 233, 0.3); }
        #video, #overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover; }
        #overlay { pointer-events: none; z-index: 10; }
        .status { background: rgba(14, 165, 233, 0.2); padding: 10px 20px; border-radius: 20px; margin-bottom: 10px; font-size: 14px; border: 1px solid #0ea5e9; font-weight: bold; color: #38bdf8; }
    </style>
</head>
<body>

    <div class="status" id="status">Iniciando C√°mara e IA...</div>

    <div class="container">
        <video id="video" autoplay playsinline muted></video>
        <canvas id="overlay"></canvas>
    </div>

<script>
    const video = document.getElementById('video');
    const canvas = document.getElementById('overlay');
    const ctx = canvas.getContext('2d', { alpha: true });
    const status = document.getElementById('status');
    
    const WIDTH = 640;
    const HEIGHT = 640;
    const CONF_THRESHOLD = 0.90; // Validaci√≥n estricta al 90%
    const IOU_THRESHOLD = 0.45;
    let session;
    let frameCount = 0;

    const offscreenCanvas = document.createElement('canvas');
    offscreenCanvas.width = WIDTH;
    offscreenCanvas.height = HEIGHT;
    const offCtx = offscreenCanvas.getContext('2d', { willReadFrequently: true });

    async function init() {
        try {
            session = await ort.InferenceSession.create('./best.onnx', { 
                executionProviders: ['wasm'],
                graphOptimizationLevel: 'all'
            });
            
            const stream = await navigator.mediaDevices.getUserMedia({ 
                video: { facingMode: "environment", width: 640, height: 480 } 
            });
            video.srcObject = stream;
            video.onloadedmetadata = () => {
                status.innerText = "üöÄ IA ACTIVA: Buscando INE (90% Confianza)";
                predict();
            };
        } catch (e) {
            status.innerText = "‚ùå Error: " + e.message;
        }
    }

    async function predict() {
        // Procesamos 1 de cada 2 frames para estabilidad
        if (frameCount % 2 === 0) {
            offCtx.drawImage(video, 0, 0, WIDTH, HEIGHT);
            const imgData = offCtx.getImageData(0, 0, WIDTH, HEIGHT).data;
            
            const input = new Float32Array(WIDTH * HEIGHT * 3);
            for (let i = 0; i < WIDTH * HEIGHT; i++) {
                input[i] = imgData[i * 4] / 255.0;           // R
                input[i + WIDTH * HEIGHT] = imgData[i * 4 + 1] / 255.0; // G
                input[i + 2 * WIDTH * HEIGHT] = imgData[i * 4 + 2] / 255.0; // B
            }

            const tensor = new ort.Tensor('float32', input, [1, 3, HEIGHT, WIDTH]);
            
            try {
                const results = await session.run({ images: tensor });
                const output = results[Object.keys(results)[0]].data;

                // Extraemos cajas con la l√≥gica de transposici√≥n de YOLOv8
                const boxes = extractBoxes(output);
                renderBoxes(boxes);
            } catch (e) {
                console.error("Error inferencia:", e);
            }
        }
        
        frameCount++;
        requestAnimationFrame(predict);
    }

    function extractBoxes(data) {
        const detections = [];
        const numRows = 8400; // Candidatos est√°ndar YOLOv8
        
        for (let i = 0; i < numRows; i++) {
            const prob = data[4 * numRows + i]; // Probabilidad clase 0 (INE)

            if (prob > CONF_THRESHOLD) {
                const cx = data[0 * numRows + i];
                const cy = data[1 * numRows + i];
                const w = data[2 * numRows + i];
                const h = data[3 * numRows + i];

                detections.push({
                    x: (cx - w / 2),
                    y: (cy - h / 2),
                    w: w,
                    h: h,
                    prob: prob
                });
            }
        }
        return nms(detections, IOU_THRESHOLD);
    }

    function nms(boxes, threshold) {
        boxes.sort((a, b) => b.prob - a.prob);
        const result = [];
        const used = new Array(boxes.length).fill(false);

        for (let i = 0; i < boxes.length; i++) {
            if (used[i]) continue;
            result.push(boxes[i]);
            for (let j = i + 1; j < boxes.length; j++) {
                if (!used[j] && calculateIoU(boxes[i], boxes[j]) > threshold) {
                    used[j] = true;
                }
            }
        }
        return result;
    }

    function calculateIoU(a, b) {
        const x1 = Math.max(a.x, b.x);
        const y1 = Math.max(a.y, b.y);
        const x2 = Math.min(a.x + a.w, b.x + b.w);
        const y2 = Math.min(a.y + a.h, b.y + b.h);
        const inter = Math.max(0, x2 - x1) * Math.max(0, y2 - y1);
        const union = a.w * a.h + b.w * b.h - inter;
        return inter / union;
    }

    function renderBoxes(boxes) {
        canvas.width = video.videoWidth;
        canvas.height = video.videoHeight;
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        // Factores de escala para ajustar el 640x640 de la IA al tama√±o real del video
        const scaleX = canvas.width / WIDTH;
        const scaleY = canvas.height / HEIGHT;

        boxes.forEach(box => {
            const x = box.x * scaleX;
            const y = box.y * scaleY;
            const w = box.w * scaleX;
            const h = box.h * scaleY;

            // Dibujar rect√°ngulo
            ctx.strokeStyle = '#00ffcc';
            ctx.lineWidth = 4;
            ctx.strokeRect(x, y, w, h);
            
            // Etiqueta
            ctx.fillStyle = '#00ffcc';
            ctx.fillRect(x, y - 25, 100, 25);
            ctx.fillStyle = '#000';
            ctx.font = 'bold 14px sans-serif';
            ctx.fillText(`INE ${(box.prob * 100).toFixed(0)}%`, x + 5, y - 7);
        });
    }

    init();
</script>
</body>
</html>
