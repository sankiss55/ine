<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <title>Detector de INE - YOLO11 Nano</title>
    <script src="https://cdn.jsdelivr.net/npm/onnxruntime-web/dist/ort.min.js"></script>
    <style>
        body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; background: #0f172a; color: white; display: flex; flex-direction: column; align-items: center; margin: 0; padding: 20px; }
        .container { position: relative; width: 640px; height: 480px; border-radius: 15px; overflow: hidden; border: 4px solid #38bdf8; box-shadow: 0 0 30px rgba(56, 189, 248, 0.4); background: #000; }
        #video, #overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover; }
        #overlay { z-index: 10; }
        .status { background: rgba(56, 189, 248, 0.15); padding: 12px 25px; border-radius: 50px; margin-bottom: 15px; border: 1px solid #38bdf8; color: #7dd3fc; font-weight: 600; }
        .error { border-color: #f87171; color: #f87171; background: rgba(248, 113, 113, 0.1); }
    </style>
</head>
<body>

    <div class="status" id="status">Cargando IA y C√°mara...</div>

    <div class="container">
        <video id="video" autoplay playsinline muted></video>
        <canvas id="overlay"></canvas>
    </div>

<script>
    const video = document.getElementById('video');
    const canvas = document.getElementById('overlay');
    const ctx = canvas.getContext('2d');
    const status = document.getElementById('status');
    
    // CONFIGURACI√ìN CLAVE
    const WIDTH = 640;
    const HEIGHT = 640;
    const CONF_THRESHOLD = 0.15; // Bajado a 45% para que detecte mejor en web
    const IOU_THRESHOLD = 0.45;
    
    let session;

    async function init() {
        try {
            // 1. Cargar el modelo ONNX
            // Nota: YOLO11 (yolo26) requiere onnxruntime-web
            session = await ort.InferenceSession.create('./best.onnx', { 
                executionProviders: ['wasm'] 
            });
            
            // 2. Iniciar C√°mara
            const stream = await navigator.mediaDevices.getUserMedia({ 
                video: { facingMode: "environment", width: 640, height: 480 } 
            });
            video.srcObject = stream;
            
            video.onloadedmetadata = () => {
                status.innerText = "üöÄ IA LISTA: Buscando INE...";
                predict();
            };
        } catch (e) {
            status.classList.add('error');
            status.innerText = "‚ùå Error: " + e.message;
            console.error(e);
        }
    }

    async function predict() {
        if (!session) return;

        // Dibujar frame actual en canvas oculto para procesar
        const tempCanvas = document.createElement('canvas');
        tempCanvas.width = WIDTH;
        tempCanvas.height = HEIGHT;
        const tempCtx = tempCanvas.getContext('2d');
        tempCtx.drawImage(video, 0, 0, WIDTH, HEIGHT);
        
        const imgData = tempCtx.getImageData(0, 0, WIDTH, HEIGHT).data;
        const input = new Float32Array(WIDTH * HEIGHT * 3);

        // Pre-procesamiento: Normalizar y organizar en formato NCHW (R, G, B)
        for (let i = 0; i < WIDTH * HEIGHT; i++) {
            input[i] = imgData[i * 4] / 255.0;           // R
            input[i + WIDTH * HEIGHT] = imgData[i * 4 + 1] / 255.0; // G
            input[i + 2 * WIDTH * HEIGHT] = imgData[i * 4 + 2] / 255.0; // B
        }

        const tensor = new ort.Tensor('float32', input, [1, 3, HEIGHT, WIDTH]);
        
        try {
            const results = await session.run({ images: tensor });
            const output = results[Object.keys(results)[0]].data;

            const boxes = extractBoxes(output);
            renderBoxes(boxes);
        } catch (e) {
            console.error("Error en predicci√≥n:", e);
        }

        requestAnimationFrame(predict);
    }

    function extractBoxes(data) {
        const detections = [];
        const numRows = 8400; // Salida est√°ndar de YOLOv8/v11 a 640px
        
        // En YOLO11 con 1 clase, la matriz es de [1, 5, 8400]
        // data[0...8399] = x
        // data[8400...16799] = y
        // data[16800...25199] = w
        // data[25200...33599] = h
        // data[33600...41999] = Score de Clase 0 (INE)

        for (let i = 0; i < numRows; i++) {
            const score = data[4 * numRows + i]; 

            if (score > CONF_THRESHOLD) {
                const cx = data[0 * numRows + i];
                const cy = data[1 * numRows + i];
                const w = data[2 * numRows + i];
                const h = data[3 * numRows + i];

                detections.push({
                    x: (cx - w / 2),
                    y: (cy - h / 2),
                    w: w,
                    h: h,
                    prob: score
                });
            }
        }
        return nms(detections, IOU_THRESHOLD);
    }

    function nms(boxes, threshold) {
        boxes.sort((a, b) => b.prob - a.prob);
        const result = [];
        const used = new Array(boxes.length).fill(false);

        for (let i = 0; i < boxes.length; i++) {
            if (used[i]) continue;
            result.push(boxes[i]);
            for (let j = i + 1; j < boxes.length; j++) {
                if (!used[j] && calculateIoU(boxes[i], boxes[j]) > threshold) {
                    used[j] = true;
                }
            }
        }
        return result;
    }

    function calculateIoU(a, b) {
        const x1 = Math.max(a.x, b.x);
        const y1 = Math.max(a.y, b.y);
        const x2 = Math.min(a.x + a.w, b.x + b.w);
        const y2 = Math.min(a.y + a.h, b.y + b.h);
        const inter = Math.max(0, x2 - x1) * Math.max(0, y2 - y1);
        const union = a.w * a.h + b.w * b.h - inter;
        return inter / union;
    }

    function renderBoxes(boxes) {
        canvas.width = video.videoWidth;
        canvas.height = video.videoHeight;
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        boxes.forEach(box => {
            // Escalar coordenadas de 640x640 al tama√±o real del video
            const x = (box.x / WIDTH) * canvas.width;
            const y = (box.y / HEIGHT) * canvas.height;
            const w = (box.w / WIDTH) * canvas.width;
            const h = (box.h / HEIGHT) * canvas.height;

            // Dibujar Caja
            ctx.strokeStyle = '#38bdf8';
            ctx.lineWidth = 4;
            ctx.strokeRect(x, y, w, h);
            
            // Dibujar Etiqueta
            ctx.fillStyle = '#38bdf8';
            ctx.font = 'bold 16px Arial';
            const txt = `INE ${(box.prob * 100).toFixed(0)}%`;
            ctx.fillRect(x, y - 25, ctx.measureText(txt).width + 10, 25);
            ctx.fillStyle = '#000';
            ctx.fillText(txt, x + 5, y - 7);
        });
    }

    init();
</script>
</body>
</html>
